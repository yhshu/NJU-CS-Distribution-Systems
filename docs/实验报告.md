# 分布式系统 课程作业

2020 年 秋季

舒意恒 MF20330067 计算机科学与技术系

[TOC]



## 一. Raft 简介

目标：实现日志复写，所有服务器能够以相同的顺序执行相同的命令，共识模块确保正确的日志复写。



#### 1.1 服务器状态

给定任意时间，每个服务器处于三种状态之一：

- Leader：处理所有客户端的交互，与日志复写
- Follower：完全被动
- Candidate：用于候选一个 Leader

通常情况下，1 个 leader 有 (N - 1) 个 Follower.



#### 1.2 活跃验证

- 服务器的初始状态是 Follower，Leaders 通过 AppendEntries RPC 发送心跳（heartbeat）来维持其控制。
- 如果在选举时限（electionTimeout）内没有收到 RPC，follower 认为 leader 已经崩溃并开始新的选举。

![img.png](img/img.png)



#### 1.3 任期（term）

![img.png](img/img2.png)

- 时间被划分为任期，每个任期包含选举和正常操作两个阶段。
    - 选举可能失败，或者最终选出一个 Leader
    - 选出一个 Leader 后，各服务器开始正常操作
- 每个服务器维护一个当前任期的值 `currentTerm`
- 任期的关键作用是，识别出过时的信息



#### 1.4 选举

服务器开始选举：自增当前任期 `currentTerm` 值，改变为 Candidate 状态，并为自身投票。

然后，向所有其他服务器发送 RequestVote，重复尝试直到以下条件之一：

1. 受到大多数服务器的投票，成为 Leader，发送 AppendEntries 心跳给所有其他服务器
2. 从有效的 Leader 收到 RPC：重新回到 Follower 状态
3. 没有服务器赢得选举（选举超时），`currentTerm` 增加，开始新的选举

选举的安全性：每个任期只允许最多一个胜选者

- 每个服务器在每个任期中只能投票一次（持久化到磁盘上）
- 同一任期内，两个不同的候选者不能同时获得多数票

![img.png](img/img3.png)

选举的有效期：必须有候选者胜出

- 每个候选者在 `[T, 2T]` 范围内随机选择选举时限
- 一个服务器通常在其他服务器开始之前发起并赢得选举
- 一般 `T` 远大于网络 RTT 时能正常工作



#### 1.5 日志结构

![img.png](img/img4.png)

日志项描述为 `Log entry = <index, term, command>`.

日志存储磁盘中，即使系统崩溃也能保存。

如果一个日志项被存储到大多数服务器上，则该日志项被视为提交。

- 提交后的日志项持久存储在磁盘中，最终会被状态机执行。



#### 1.6 正常操作

![img.png](img/img5.png)

客户端发送命令给 Leader，Leader 将命令存储到日志当中，并通过 AppendEntries RPC 发送给其他 Follower.

一旦一个新的日志项被提交：

- Leader 将命令发送给状态机，并将结果发送给客户端。
- Leader 在随后的 AppendEntries 中携带对 Follower 的心跳信号。
- Follower 将已提交的命令传递给他们的状态机。

如果遭遇崩溃，或者 Follower 响应慢：Leader 重复尝试直到成功。

该方法的性能在通常情况下是最优的，一次成功的 RPC 可以发送给大多数的服务器。



#### 1.7 日志操作：一致性检查

![img.png](img/img6.png)

- AppendEntries 在新日志项之前有 `<index, term>` 项。
- Follower 必须包含匹配的项，否则拒绝。
- 实现一个归纳步骤，确保一致性。



#### 1.8 安全要求

一旦将日志项给定一个状态机，其他状态机不得为该日志项给定不同的值。

Raft 的安全属性：如果一个 Leader 决定提交一个日志项，则该日志项将出现在未来所有 Leader 的日志中。

为什么这一点能保证高层的目标：

- Leader 从不会重写他们自己的日志。
- 只有 Leader 日志中的日志项可以被提交。
- 而日志项必须在应用到状态机之前被提交。

![img.png](img/img7.png)



#### 1.9 选择最佳的 Leader

一些情况下我们难以分辨哪些日志项已经被提交。

![img.png](img/img8.png)

期望的最佳候选者是最有可能包含所有已提交日志的候选者。

- 在 RequestVote 中，候选者包括最后一个日志项的 `index + term`.
- 投票者如果包含更完整的日志，可以拒绝投票：有更新的 term，或者在同一 term 中有更高编号的日志项
- Leader 会有相对于大多数投票者更完整的日志。



#### 1.10 修复 Follower 的日志

![img.png](img/img9.png)

新的 Leader 必须使 Follower 的日志与其日志保持一致：删除不相关的日志项，并补充缺失的日志项。

Leader 为每一个 Follower 维护一个 `nextIndex`.

- 下一个日志项的索引发送给 Follower
- 初始化为 (1 + leader 的最后一个索引)

如果 AppendEntries 的一致性检查失败，nextIndex 自减，并重试。

![img.png](img/img10.png)



#### 1.11 原 Leader 的离任

Leader 如果临时断连，其他服务器选举新的 Leader，如果原 Leader 重新连接，原 Leader 重新尝试提交日志项。

任期可用于区分过期的 Leader 和候选者：

- 每个 RPC 都包含发送者所处的任期
- 如果发送者的任期小于接受者的任期： 接受者拒绝 RPC
- 如果接受者的任期小于发送者的任期： 接受者改变为 Follower，更新任期，再处理 RPC

选举需要更新多数服务器的任期： 被废置的服务器不能提交新的日志项。



#### 1.12 客户端协议


- 发送命令给 Leader：如果 Leader 是未知的，联系任意服务器，并将客户端重定向到 Leader
- Leader 只在命令被日志记录、提交、执行后响应
- 如果请求时间超时（例如，Leader 崩溃）：
   - 在重定向之后，客户端重新向新 Leader 请求
- 确保只有一个 Leader，即使 Leader 崩溃
   - 例如，Leader 可能执行完指令，但是在响应前崩溃
   - 客户端应该将 ID 嵌入到命令中
   - 客户端 ID 应该包含在日志项中
   - 在接受请求之前，Leader 检查日志项中是否是同一 ID



## 二. 实验内容

### 2.1 实验一

- 修改 `raft.go` 中的 `Make()` 函数以构建一个后台 goroutine，当它一段时间内没有收到来自其他结点的消息时，通过发送 RequestVote RPC 开始一项选举。
    - 实现 `RequestVote` RPC handler，服务器会开始投票
- 为了实现心跳，定义一个结构 `AppendEntries`，并使 leader 周期性地将它发出。
    - 需要实现 `AppendEntires` RPC handler.
- 确保选举超时不会总是同时触发。



### 2.2 实验二

在实验一的基础上，实现 leader 和 follower 的代码，添加新的日志项。

- 实现 `Start()`，完成 `AppendEntries` RPC 结构，发送信息，并完成 `AppendEntry` RPC handler.
- 通过 `TestBasicAgree()` 测试，尝试通过 `Persist` 前所有测试。



### 2.3 实验三（可选）

- 处理 Raft 协议的容错机制。
    - 需要 Raft 在重启后保持一致状态。
- 无需使用磁盘，通过 Persister (见 `Persister.go`) 保存和恢复状态。
    - 通过 Persister 初始化状态，当状态变化时通过它保存持久化状态。
- 确定服务器在 Raft 协议的哪些地方需要持久化其状态，并在这些地方插入对 persist() 的调用。



## 三. 算法设计

本项目通过 Golang 进行开发，Golang 是一种支持并发的常用于服务器的编程语言。通过 Golang 实现 Raft 算法是理解该算法的一种有效方式。





## 四. 测试方法

测试方法编写在 `src/raft/test_test.go` 文件中，主要进行以下测试。



### 4.1 TestInitialElection

1. 创建包含 3 台服务器的集群
2. 检查 leader 是否被正常选举出，检查每个任期是否只有不超过一个 leader
3. 检查在网络正常的情况下，休眠一段时间后，检查任期是否变化



### 4.2 TestReElection

1. 创建包含 3 台服务器的集群
2. 检查 leader 是否被正常选举出，检查每个任期是否只有不超过一个 leader，将该 leader 称为 leader1
3. 将该 leader1 断开连接，检查是否有新的 leader2 被选举出
4. 重新连接 leader1，并不对 leader2 作干扰
5. 断开两台服务器的连接，这时不会有 leader 被选举出来，没有追随者投票
6. 逐一恢复两台服务器的连接，检查是否有新的 leader 被选举出来



### 4.3 TestBasicAgree

1. 创建包含 5 台服务器的集群
2. 进行三轮迭代，每轮迭代 `Start` 一个命令，检查命令是否已正确复制到集群中所有服务器上



### 4.4 TestFailAgree

1. 创建包含 3 台服务器的集群
2. `Start` 一个命令，检查命令是否已正确复制到集群中所有服务器上
3. 断开某台服务器的连接，`Start` 若干命令，检查命令是否已正确复制到 2 台已连接的服务器上
4. 重新连接之前断开的服务器，`Start` 若干命令，检查命令是否已正确复制到 3 台已连接的服务器上



### 4.5 TestFailNoAgree

1. 创建包含 5 台服务器的集群
2. `Start` 一个命令，检查命令是否已正确复制到 5 台服务器上
3. 断开其中 3 台服务器的连接，`Start` 一个命令，检查命令是否被复制到已连接的服务器上
4. 重新连接断开服务器的连接， `Start` 一个命令，检查命令是否已正确复制到所有已连接的 5 台服务器上



### 4.6 TestConcurrentStarts

1. 创建包含 3 台服务器的集群
2. 进行五轮迭代，每轮迭代中 `Start` 一个命令，然后并发 `Start` 其他五个命令，检查所有命令是否已正确复制到所有服务器上；检查通过一次即退出迭代



### 4.7 TestRejoin

1. 创建包含 3 台服务器的集群
2. `Start` 一个命令，检查命令是否已正确复制到 3 台服务器上
3. 将第 2 步中的 leader1 断开连接，并在 leader1 中 `Start` 个命令；由于 leader1 已断开，命令是无效的
4. `Start` 一个命令，检查命令是否已正确复制到已连接的 2 台服务器上
5. 将第 4 步中的 leader2 断开连接，并重新连接 leader1
6. `Start`一个命令，检查命令是否已正确复制到已连接的 2 台服务器上
7. 重新连接 leader2 并 `Start` 一个命令，检查命令是否已正确复制到已连接的 3 台服务器上

TestBackup 过程与之类似，但条件更加苛刻。



### 4.8 TestCount

检查产生 leader 所需的 RPC 数量是否太高。



### 4.9 TestPersist1 / TestPersist2 / TestPersist3

基本过程是测试服务器宕机后，能否恢复到宕机之前的状态。

如果未实现状态的持久化，在宕机恢复后状态为空，`Start` 命令会导致和已提交的日志不一致。





## 五. 实验演示

算法通过 `src/raft/test_test.go` 中的测试函数进行测试，测试效果如下图所示。



![img.png](img/test_test.png)



测试函数打印的信息具体如下：

```
=== RUN   TestInitialElection
Test: initial election ...
  ... Passed
--- PASS: TestInitialElection (2.51s)
=== RUN   TestReElection
Test: election after network failure ...
  ... Passed
--- PASS: TestReElection (4.51s)
=== RUN   TestBasicAgree
Test: basic agreement ...
  ... Passed
--- PASS: TestBasicAgree (0.47s)
=== RUN   TestFailAgree
Test: agreement despite follower failure ...
  ... Passed
--- PASS: TestFailAgree (5.31s)
=== RUN   TestFailNoAgree
Test: no agreement if too many followers fail ...
  ... Passed
--- PASS: TestFailNoAgree (3.40s)
=== RUN   TestConcurrentStarts
Test: concurrent Start()s ...
  ... Passed
--- PASS: TestConcurrentStarts (0.57s)
=== RUN   TestRejoin
Test: rejoin of partitioned leader ...
  ... Passed
--- PASS: TestRejoin (3.72s)
=== RUN   TestBackup
Test: leader backs up quickly over incorrect follower logs ...
  ... Passed
--- PASS: TestBackup (16.61s)
=== RUN   TestCount
Test: RPC counts aren't too high ...
  ... Passed
--- PASS: TestCount (2.07s)
=== RUN   TestPersist1
Test: basic persistence ...
  ... Passed
--- PASS: TestPersist1 (3.04s)
=== RUN   TestPersist2
Test: more persistence ...
  ... Passed
--- PASS: TestPersist2 (16.91s)
=== RUN   TestPersist3
Test: partitioned leader and one follower crash, leader restarts ...
  ... Passed
--- PASS: TestPersist3 (1.30s)
=== RUN   TestFigure8
Test: Figure 8 ...
  ... Passed
--- PASS: TestFigure8 (27.20s)
=== RUN   TestUnreliableAgree
Test: unreliable agreement ...
  ... Passed
--- PASS: TestUnreliableAgree (2.76s)
=== RUN   TestFigure8Unreliable
Test: Figure 8 (unreliable) ...
  ... Passed
--- PASS: TestFigure8Unreliable (29.57s)
=== RUN   TestReliableChurn
Test: churn ...
  ... Passed
--- PASS: TestReliableChurn (16.51s)
=== RUN   TestUnreliableChurn
Test: unreliable churn ...
  ... Passed
--- PASS: TestUnreliableChurn (16.49s)
PASS
```





## 六. 小结

本项目部分实现了一种分布式系统中的共识算法 Raft。
Raft 替代了 Paxos 算法，其目标在于提供更清晰的逻辑分工，使得算法能够被更好地理解，同时安全性更高。

Raft 算法中解决的最重要的一些问题包括，领袖选举、日志复写、安全性。



### 6.1 领袖选举

当算法开始，或领袖（leader）崩溃或断开连接时，该集群需要选举出新的领袖。 此时，集群进入新的任期（term），如果新的领袖被成功选举出则开始这一任期的工作，反之开始下一新的任期进行重新选举。

领袖选举是通过选举的候选者（candidate）发起的，而候选者的产生是任何在其时限内没有收到心跳包（heartbeat）的服务器。即一个任期的追随者（follower）如果没有在时限内收到心跳包，就将任期编号自增、向其他所有服务器宣布竞选与拉票、并为自身投一票。

每个服务器在每个任期中仅能投一票，该票投给最早拉票的服务器。

除追随者外，一个候选者也可能收到拉票。如果候选者收到其他候选者的拉票，且任期编号不小于其自身任期编号，则放弃竞选并投票给该候选者，转变为追随者。一个候选者收到过半选票，即当选为新的领袖。如果在时限内没有选出领袖，则该任期自动终止，新的任期及选举开始。

每个服务器的超时时限都是随机的，这降低了服务器同时开始竞选的几率，并降低两候选者获得票数均不过半导致的选举没有产生领袖的几率。



### 6.2 记录复写

记录复写的工作主要由领袖负责。领袖接受来自各服务器的指令，将指令写入自己记录的新指令部分，然后将指令转发给追随者。如果追随者没有响应，领袖将不断重发指令，直到每个追随者都成功将新指令写入记录为止。

当领袖收到过半追随者确认写入的消息，就将指令视为已提交（committed）。当追随者确认指令状态变为已提交，就开始在其状态机上执行指令。

当领袖宕机时，领袖记录的某些新指令可能还没有复写到集群整体中，造成集群记录处于不一致的状态。

新领袖需要重新维护日志的一致性，让追随者的记录与其保持一致。新领袖将于每个追随者比对记录，找出两者一致的最后一项指令，删除追随者之后的指令，将自己之后的指令拷贝给追随者。新领袖与所有追随者比对完成后，每个服务器的记录就重回一致。



### 6.3 安全性

如论文图 3 所示，Raft 的安全性主要体现在：

- 选举安全：每个任期最多只选出一个领袖，不存在多个领袖的状态。
- 指令附加：新指令会附加在记录尾端，不会改写之前的指令或者删除已有指令。
- 记录一致：如果某个指令在两个记录中的任期和指令序号一致，则保证序号较小的指令也完全一致。
- 领袖完整性：某个指令在某个任期中存储成功后，则保证它存在于领袖该任期之后的记录中。
- 状态机安全：如果某服务器在其状态机上执行了某指令，其他服务器保证不会在相同状态上执行不同的指令。